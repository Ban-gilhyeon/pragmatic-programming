## 순환 참조 
: 순환 참조는 그냥 얼굴에 침뱉기임 -> 면죄부로 양방향 매핑.. 

## 안티패턴
### 스마트UI 
`controller`에 너무 많은 역할을 준 형태 하면 안됨  -> 서비스 로직도 들고 있는 유능하지만 노예같은 회사원 느낌 하면 안됨..

### 양방향 레이어드 아키텍처 
레이어드 아키텍처에서 정의한 레이어들의 의존관계에 양방향 의존이 발생하는 경우 -> 사실상 순환참조인듯?

### 트랜잭션 스크립트 
비즈니스 레이어에 위치하는 서비스 컴포넌트에서 발생하는 안티패턴
서비스 컴포넌트의 구현이 사실상 어떤 **트랜잭션이 걸려있는 스크립트**를 실행하는 것 처럼 보일 때 
(스마트 UI의 서비스 버전이라고 생각해도 될듯) -> 알고리즘 덩어리 -> 절차지향적일 확률 Up

### 서비스
: `DDD(도메인 주도 설계 : 도메인을 탐색하고, 탐색 내용을 바탕으로 SW 설계)`에서 시작된.. 개념 
캡술화된 상태 없이, 모델과는 독립된 동작을 제공하는 인터페이스
- DDD 에서 도메인은 비즈니스 영역이며 문제 영역이다
- DDD 에서 서비스는 도메인 문제를 해결하기 위한 패턴 중 하나
- 서비스는 객체(도메인)가 처리하기에 애매한 연산 로직을 갖고 있는 컴포넌트
- 도메인 개발에 필요하지만 객체로 펴현하기 애매한 로직을 처리하는 서비스를 `도메인 서비스`라 함
- 애플리케이션 개발에 필요하지만 객체로 표현하기 애매한 로직을 처리하는 서비스를 `애플리케이션 서비스`라고 함<br>
객체지향 관점으로 보는 서비스
- 서비스는 가능한 적게 만들고, 얇게 유지 -> 로직의 길이가 최대한 짧게 -> 도메인 객체로 옮겨 
	- 이 때 고민할 수 있는게 기존의 도메인 객체에 들어갈 수 있는가? 
	- 없다면 새로 도메인 모델로 만들 수는 없는지? 
- 서비스보다 풍부한 도메인 모델을 만들어야 함 -> 위와 같은 결론이 나겠네
- 서비스는 불변성을 가짐 -> 계산식 그자체임 -> 같은 논리 입력받으면 같은 응답이 당연함  -> 생성자 주입을 하는게 유리함 -> @RequireArgsConstructor 만세<br>
서비스 관련 행동 조언
- 서비스의 멤버 변수는 모두 final
- 서비스에 세터 지양
- 반드시 생성자 주입 @RequireArgsConstructor 만세
- 비즈니스 로직을 도메인에 양보
- 얇게 유지 

###  아키텍처
**아키텍처** : 구조에 제약을 걸면 아키텍처라고 할 수 있음
	-  아키텍처는 제약 조건을 이용해 해도 되는 것과 안되는 것을 결정하고 이를 개발단계에서 일어나지 않게 원천 차단함
	- 정책과 같음

#### 레이어드 아키텍처
- 레이어 구조를 사용
- 레이어 간 의존 방향은 단방향으로 유지
- 레이어 간 통신은 인접한 레이어에서만 이뤄지도록 함
`Controller
`Service
`JpaRepository

아키텍처 관해 이야기할 때 세부사항은 최대로 미뤄라.. Spring, JPA는 세부사항이므로 
우선 도메인에 따른 기술 스택이 설정되어야 함 

#### 진화한 레이어드 아키텍처 
애플리케이션의 본질은 도메인이므로 개발 첫 시작은 `도메인`에서 부터 시작함 
`Controller`
`Service`
`Domain`
- 주요 도메인 객체들 표현 (순수 자바 코드로만 작성해야 됨 @Service, @Entity와 같이 Spring JPA 어노테이션 지양)
`Repository`

