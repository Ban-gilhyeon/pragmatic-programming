해당 포스팅은 [자바/스프링 개발자를 위한 실용주의 프로그래밍 - 김우근]책을 읽고 공부한 내용을 바탕으로 이루어져 있습니다.

내용의 상당 수 부분은 책의 문장을 인용하였습니다.

# 테스트

소프트웨어의 품질과 기능을 확인하고 버그를 찾아내는 과정을 말한다.

### 효과

- 회귀 버그 줄임 -> 문제 부분 빠르게 진단
- 좋은 설계 유도

우선 회귀 버그에 대한 필요성부터 살펴본다.

# 회귀 버그
"Regression Bug"

시스템에서 정상적으로 제공하던 기능이 **어떤 배포 시점**을 기준으로 제대로 동작하지 않게 되는 상황을 말한다.

여기서의 '어떤 배포 시점'은 **기능 개발이 제대로 돼 있지 않던 과거**를 의미한다.

> 앞으로 나올 내용은 이 '회귀 버그'를 테스트를 통해 어떻게 해결하는지 설명.

# 자동 테스트의 중요성

### 인수 테스트

인수인계할 때 그 인수.

시스템이 비즈니스 요구사항을 만족해서 소유권을 넘기기 전에 수행하는 테스트 단계

이는 **최종 단계**에 수행하는 테스트로, 시스템을 고객에게 전달하기 전 '사용자 관점'에서 전체 시스템을 검증.

- 최대한 실제 환경에 가까운 테스트 환경 구성 필요
- 테스트 데이터를 미리 잘 쌓아두는 등의 작업 필요
-> CBT(closed beta test), staging

### 수동, 자동

위 인수 테스트를 수동으로 하게 된다면, 
- 많은 시간과 노력
- 실수 가능성
- 버그 상황을 눈치 못챌 수 있음

그리고 수동 테스트는 누적이 되지 않아 테스트 담당자는 새로운 버전이 나올 때 마다 이 일을 반복적으로 수행해야 함.

일일이 postman으로 url, header, body값 입력해가며 테스트하고, 로그를 확인하면서 개발한 경험이 있다면, 또 이런 반복적인 행동에 기가 다 빨려버린 경험이 있다면 이는 수동 테스트만을 해온 것.

즉, 이 **오류를 탐지할 수단이 수동으로 직접 테스트 해보는 방법밖에 없어서 유지 보수가 매우 힘들어진다.**

만일 이 인수 테스트를 자동으로 구성한다면,
수동 테스트의 문제점을 모두 해결할 수 있다.

# 단위 테스트의 중요성

단위 테스트를 어떤 관점에서 봐야 하는지를 파악해보자.

### 구글의 테스트 피라이드 모델
![image](https://github.com/user-attachments/assets/c021f1a0-b93b-4688-a3f8-599421d4d1fe)

보통은 이런 테스트 피라미드를 떠오를 것이다.[Fixing a Test Hourglass - Google Testing Blog Alan Myrvold](https://testing.googleblog.com/2020/11/fixing-test-hourglass.html "Fixing a Test Hourglass")

구글에서는 새로운 패러다임을 제시했다.
- 단위 테스트 -> 소형 테스트
- 통합 테스트 -> 중형 테스트
- End-to-end 테스트 -> 대형 테스트

테스트를 소,중,대로 크기 순으로 분류했다. 이런 분류의 기준은,
> 테스트는 '결정적'이고 '빠를수록' 좋다.

에 기반하고 있다.

### 신뢰
똑같은 테스트를 실행하더라도 어떤 때는 성공하고 어떤 때는 실패하는 테스트가 만들어질 수 있다. 이러한 테스트를 가리켜 비결정적 테스트(non-deterministic test)라고 한다.

비결정적인 테스트 상황은 다음과 같다.
- 어떤 테스트는 아침에 실행했을 때 성공하고, 저녁에 실행하면 실패한다.
- 테스트 환경에서 H2로 테스트 했다가 실제 배포 환경에서 MySQL로 테스트 하면, 쌓인 데이터가 달라 실패한다.
- 외부 환경이 제대로 동작하지 않거나 통신이 단절될 때 실패한다.
- ...

💡 여기서 결정적이란, **같은 코드를 대상으로 실행하는 테스트는 항상 같은 응답을 해야 함**을 의미한다.

버그를 찾아내려 할 때, 비결정적인 테스트가 많이 존재할수록 원인을 파악하기 힘들 것이다.

반면, 결정적인 테스트는 **버그를 재현하기 쉽다.** 버그가 발생했을 때 원인이 되는 입력이 무엇인지 바로 확인할 수 있기 때문이다. 테스트가 결정적이라면 무조건 같은 응답이 보장되기 때문에 테스트 실행하고, 실패한 부분을 찾아 원인을 분석하기 쉽지 않을까?

여기서 테스트의 주 목적을 확인할 수 있다.
> 테스트의 주 목적 중 하나는, **시스템에 문제가 발생했을 때 문제가 되는 부분을 빠르게 진단할 수 있게 하기 위함**입니다. 그리고 이를 위해서는 테스트가 같은 입력에 같은 결과를 보장해야 합니다.

### 속도
테스트 속도가 느리면 개발자들은 테스트를 실행하는 데 부담을 느끼며, 그로 인해 테스트를 관리하고 싶다는 의욕도 크게 줄어든다.

테스트 속도를 낮추는 대표적인 요인들은 다음과 같다.
- 테스트가 병렬 처리 혹은 블로킹 호출을 사용하는 경우
  -> 실행 순서를 보장할 수 없다.
- 테스트가 디스크 I/O를 사용할 경우
  -> 읽기 쓰기 결과가 다를 수 있다.
- 테스트가 다른 프로세스와 통신할 경우
  -> 통신에 문제가 생길 수 있다.
- 테스트가 외부 서버와 통신할 경우
  -> 통신에 문제가 생길 수 있다.

테스트를 할 때 스프링 구동이 필요할까? H2 연결이 필요할까?

이제 다시 구글이 제시한 테스트 피라미드를 파헤쳐보자.

- 소형 테스트: 단일 서버, 단일 프로세스, 단일 스레드에서 동작하며 디스크 I/O, 블로킹 호출이 없는 테스트를 의미합니다.
- 중형 테스트: 단일 서버에서 동작하되, 멀티 프로세스, 멀티 스레드를 사용할 수 있는 테스트를 의미합니다.
- 대형 테스트: 멀티 서버에서 동작하는 테스트를 의미합니다.

소형 테스트가 다음과 같이 정의된다면, 우리는 **해당 테스트 모두를 병렬로 실행**할 수 있을 것이며, **레지스터, 메모리에서 모든 작업이 처리**되기 때문에 **속도를 높일 수 있을 것**이다.

그래서 우리는 소형 테스트를 많이 작성해야 한다.

### 도메인이 비즈니스 로직 처리

소형 테스트를 위해서 도메인이 비즈니스 로직을 처리하는 것이 좋다.

🤔 외부 모듈과 협력할 일이 없기 때문이라고 해석했는데, 이 부분은 토론이 좀 필요한 것 같다.

### 정리

정리하면 다음과 같다.
- 결정적인 테스트를 작성하면 회귀 버그를 탐지하는 데 수월해진다.
- 소형 테스트를 많이 작성할 수록 테스트 속도가 높아진다.

구글
- 단위 테스트는 매우 중요하다.
- 테스트는 결정적이고 빠를수록 좋다.
- 단위 테스트가 80%, 통합 테스트가 15%, E2E 테스트가 5% 정도가 좋다.

# 테스트 대역

결정적인 테스트를 작성하기 위해 테스트 대역을 활용할 수 있다.

테스트 대역을 활용하여 **외부 세계를** 정상적인 상황, 장애 상황, 타임아웃 상황 등으로 **개발자가 직접 연출**할 수 있다.

### 대역

진짜가 아닌 가짜 객체나 컴포넌트.

대역이 '어떻게 동작하느냐'에 따라 5가지로 분류된다.

- Dummy: 아무런 동작을 하지 않습니다.
- Stub: 지정된 값만 변환합니다.
- Fake: 자체적인 로직이 있습니다.
- Mock: 아무런 동작을 하지 않습니다. 대신 어떤 행동이 호출됐는지를 기록합니다.
- Spy: 실제 객체와 똑같이 행동합니다. 그리고 모든 행동 호출을 기록합니다.

하나씩 살펴보자.

### Dummy

아무런 동작을 하지 않는 것으로써, **코드가 정상적으로 돌아가게 하기 위한 역할**만 수행한다.

해당 단위 테스트에서 필요하지 않은 의존성을 대신 주입해줄 수 있다.

```java
new Service(~~~, ~~~, new Dummy__());
```

크게 2가지 방식으로 Dummy를 주입시킬 수 있다.
- 맴버 변수에 주입
- 필수 매개변수가 포함된 메서드에 익명클래스로 주입

```java
somethingFilter.doFilter(servletRequest, servletResponse,
    new FilterChain() {
      @Override
        public void doFilter(ServletRequest req, ServletResponse res) {
          // do nothing
        }
      });
```

⚠️ 어떤 특정한 상황에서만 사용되는 게 아니다. 위와 같이 메서드 호출 시 사용되는 매개변수에도 사용될 수 있고, 도메인 객체를 사용하는 어디서든 사용할 수 있다.

### Stub

직역하면 '부본', '짧은 부분'.
부본이란, 원본과 비슷하게 만들어 참고로 보관하는 서류를 의미한다.

개발 세계에서도 비슷한 의미로 해석된다.
**실제 객체의 '응답'을 최대한 비슷하게 따라하는 대역**이다. '응답'이라는 한정된 상황에 주목하자.

즉, 미리 준비된 값을 반환하도록 개발자가 의도할 수 있다는 것.

그러면 Stub을 어떨 때 사용할 수 있을까?

미리 준비한 값을 그대로 반환하여 **고연산 작업이 실제로 실행되지 않게** 한다.
메서드 호출 결과가 뻔한 것에 비해 동작이 지나치게 복잡할 경우.

- healthCheck는 "OK"만 받는데 비해 앞단의 서버 로직을 모두 거쳐야 할 때
- 이메일 전송 호출
- repository 조회 로직
- ...

그래서 주로 **외부 연동을 하는 컴포넌트나 클라이언트를 대체**하는 데 자주 사용된다.

예를 들어, 이메일 전송을 호출했는데 timeout이 발생한 상황도 연출할 수 있다. `VerificationEmailSenderTimeout`이라는 Stub을 만들어 **항상 타임아웃인 상황을 가정**한 채로 테스트를 진행할 수 있고 이는 **결정적**으로 동작하게 만들 수 있다.

하지만 이 stub도 단점을 가지고 있는데
- **모든** 테스트에 stub을 넣는 일은 **상당히 힘든 일**
- stub이 테스트의 대부분을 차지하여 **테스트의 중요한 부분을 가릴 수 있다**.

이를 다음에 소개하는 Fake로 해결할 수 있다.

### Fake

테스트를 위한 자체적인 논리를 가지고 있다.

바로 위에서 stub의 단점을 설명하고 이를 해결할 수 있는 방법으로 Fake를 소개했다. 간단한 예시를 들어보자.

UserRepository의 find, save, remove 등을 일일이 테스트 마다 stub 하는것은 매우 힘든 일일 것이다.(실제로 정확히 위 2가지 문제점을 경험할 수 있었다.)

그럼 UserRepository를 그대로 흉내낼 수 있는 대역이 있다면 어떨까? 정확히 RDB를 흉내낼 순 없지만 코드 상으로 데이터 저장을 위한 간단한 메모리 변수를 만들어낼 순 있을 것이다.

```
UserRepository <- UserRepositoryImpl[실제 환경]
<<interface>>  <- UserFakeRepository[테스트 환경]
```

이렇게 되면 위 2가지를 해결할 수 있다!

또한 한가지 더 얻게 되는데, 
- 로컬 환경에서 데이터베이스와 연동하지 않고도 서버를 구동시킬 수 있다.
는 점이다.

💡 `@Profile("!local")`을 활용하여 Spring의 의존성 주입을 환경마다 다르게 세팅 가능. 하지만 SpringContext를 사용하는 것 보다 Spring 구동 없이 테스트를 작성하는 것이 최우선.

### Mock

직역하면 '모조품'이다.
주로 **메서드 호출이 발생했는지 여부**를 검증하는 역할을 담당한다.

다음과 같은 기능을 수행한다.
- 메서드 호출 및 상호 작용을 기록한다.
- 어떤 객체와 상호 작용이 일어났는지 기록한다.
- 어떻게 상호 작용이 일어났는지 기록한다.

그럼 여기서 '상호 작용'이란 무엇일까
상호 작용은 '행위 기반 검증(behavior-based verification)'을 말한다.

이는 테스트 대상이나 협력 객체, 협력 시스템의 **메서드 호출 여부**를 본다.
이를 협력 객체와 '상호작용'했는지 확인한다고 해서 '상호 작용 테스트'라고도 불린다.

행위 기반 검증 보다는 상태 기반 검증을 우선시 해야 되는데, 이에 대한 내용은 뒤에서 더 자세히 다룬다.

```java
public class MockVerificationEmailSender implements VerificationEmailSender {
	public boolean isSendCalled = false;
	
	@Overrid
	public void send(User user) {
		this.isSendCalled = true;
	}
}

// to use
MockVerificationEmailSender verificationEmailSender = new MockVarificationEmailSender();

assertThat(verificationEmailSender.isSendCalled).isTrue();
```

💡 `isSendCalled` 맴버 변수가 public인 것에 불편해 할 필요가 없다. test에서만 사용되기 때문에 오픈해도 상관 없다.

### Spy

mock과 하는 역할은 동일하다.

다만 차이가 있다면, 다른 테스트 대역들은 가짜 객체이기 때문에 내부 동작이 없는 반면, Spy는 **실제 우리가 만들었던 객체 그대로 사용하여 실제 객체인 것 처럼 행동**한다.

```java
Mockito.mock(ArrayList.class);

Mockito.spy(new ArrayList<~~>());
```

이것도 라이브러리 도움 없이 직접 구현할 수 있다.

- 상속을 이용한 방법

```java
public class SpyUserRepository extends UserRepositoryImpl {
	public int findByEmailCallCount = 0;

	@Override
	public Optional<User> findByEmail(String email) {
		this.findByEmailCallCount++;
		return super.findByEmail(email);
	}
}
```

- 프록시 패턴을 이용한 방법
```java
@Repository
@RequiredArgsConstructor
public class SpyUserRepository implements UserRepository {
	public int findByEmailCallCount = 0;
	private final UserRepositoryImpl userRepositoryImpl;

	@Override
	public Optional<User> findByEamil(String email) {
		this.findByEmailCallCount++;
		return userRepositoryImpl.findByEmail(email);
	}
}
```

- Mockito 라이브러리 사용
```java
spy(new UserRepository());

given().thenReturn();

verify(userRepositorySpy.times(2)).findByEmail(anyString());
```

### 오해

⚠️ Mockito 라이브러리는 테스트 대역 자체를 만들 수 있는 라이브러리이다. mock 이외에 stub도 만들 수 있다. 우리가 보는 `when().thenReturn()` 구조는 stub이다.

⚠️ 라이브러리, 프레임워크의 도움 없이도 문제를 해결할 수 있는 경우가 더 높은 품질의 코드를 갖추고 있을 것이다. 라이브러리는 그저 테스트 대역을 쉽게 구현할 수 있게 도와주는 편의성 용도이다.

### 정리

테스트 대역을 무작정 사용하는 것 보다, 이들의 용도가 무엇이고 어디에 사용되는지를 파악하는 것이 더 높은 품질의 설계를 얻을 수 있다.

그리고 앞서 사례들을 살펴봤듯, 추상화가 잘 되어 있을수록, 의존성 역전이 잘 되어 있을수록 테스트 대역을 사용하기 용이하다는 것 까지 알 수 있다.
