테스트 Part 1과 이어지는 내용입니다.

우리는 이때까지 회귀 버그를 찾아내는 수단, 방지하는 수단으로 테스트를 학습했다.

테스트 효과의 두번째인 좋은 설계에 대해 알아보자.

# 테스트 가능성

"Testability"

테스트 하기 쉬운 코드는 테스트 가능성이 높고, 좋은 설계일 확률이 높다.

우리는 테스트 하기 쉬운 코드를 작성하기 위해 노력해야 한다.

테스트 하기 쉬운 코드가 왜 품질을 개선하는지는 나중에 다룬다.

### 테스트하기 쉬운 요소

테스트 하기 쉬운 요소와 어려운 요소를 판단하는 기준은 무엇일까?

> 테스트 하려는 대상의 입력과 출력

### 숨겨진 입력

```java
private void login() {
	//..
	this.lastLoginTimeStamp = Clock.systemUTC().millis();
}

// test
long expected = Clock.systemUTC().millis();
assertThat(user.getLastLoginTimeStamp()).isEqualsTo(expected);
```

상태 기반 테스트를 하기 위해 변경된 상태값이 유효한지 비교하는 테스트이다.

`login()` 메서드 안에서의 `lastLoginTimeStamp`와 test에서의 `expected` 를 비교해보자.

해당 테스트는 결정적일까? 시간을 가져오는 시점이 달라 다른 값이 저장되는 것을 알 수 있다. 비결정적이다.

이를 테스트할 수 있는 방법이 있다.
- `isGreaterThan(0)`
- Mockito를 이용한 stub

하지만 이는 임시 방편일 뿐이고, **해당 메서드의 구조를 파악하는 것이 우선이다. 근본적인 이유를 고민해보자.**

`login()` 메서드의 내부에서 '현재 시각을 가져오는' 행위가 포함되어 있다. 이는 또다른 숨겨진 입력이다. **메서드를 실행하는 데 필요하지만 외부에서는 이를 알 수 없는 감춰진 입력.**

그래서 숨겨진 입력을 바깥으로 드러내보자.

```java
public void login(long currentTimestamp) {
	//..
	this.lastLoginTimestamp = currentTimestamp;
}

// test
long currentTimestamp = Clock.systemUTC().millis();
user.login(currentTimestamp);

assertThat(user.getLastLoginTimestamp()).isEqualsTo(currentTimestamp);
```

메서드의 매개변수로 들어내니, **모종의 이유로 메서드 실행을 위해 현재 시각이 필요하다는 사실을 외부에서 알 수 있었다.**

하지만 User domain에서 외부로 드러내고 보니 Service 코드에서는 숨겨진 입력처럼 작용했다. 즉, 어찌되었든 `Clock.systemUTC().millis()`를 어느 한 곳에는 작성을 해야 했다.

이럴 때, 의존성 주입 + 의존성 역전을 사용해보자.

```java
public class UserService {
	private final UserRepostiory userRepository;
	private final ClockHolder clockHolder;

	public User login(String email) {
		User user = userRepository.getByEmail(email);
		user.login(clockHolder.now());
		user = userRepository.save();
		return user;
	}
}
```

```
UserService -> ClockHolder  <- SystemClockHolder [배포 환경]
              <<interface>> <- TestClockHolder [테스트 환경]
```

이전에는 직접 사용자 입장에서 Clock을 사용하여 현재 시간을 가져왔다면, 의존성 주입과 역전을 사용하여 사용자가 `ClockHolder`라는 interface에게 호출할 수 있다.

환경을 다르게 세팅하여 구성했더니, 사용자 입장에서 직접 "현재 시간"만 넣어주면 되었다! **구현체에 의존하지 않고 책임에 따른 인터페이스에 의존하기 때문에 환경에 따라 다른 구현체가 실행되게 할 수 있다.**

**그리고 이는 곧 확장성과 유지보수에 능한 코드가 된다.**

```java
public class User {
	private long lastLoginTimeStamp;

	public void login(ClockHolder clockHolder) {
		this.lastLoginTimeStamp = clockHolder.now();
	}
}
```

숨겨진 입력을 어디서 드러내야 좋은 코드일까? 이는 관련 없다. **뭐든지 테스트 하기 쉬운 코드가 되면 된다!**

### 숨겨진 출력

반환 값 외에 존재하는 모든 부수적인 출력.

```java
System.out.println("...")'
```

이 표준 출력을 확인할 길이 있을까? 이는 코드 밖에서 벌어지는 일이다. 우리가(사용자가) 확인할 수 없다.

숨겨진 출력을 드러내는 방법은 어떤게 있을까?

- 반환값 이용
- 반환 DTO 사용
- 반환 이벤트 생성

하지만 뭔가 명확한 해답이 되지 못한다. 반환 값을 여러개 하면 요구사항을 예측하기 힘들어진다. 제일 중요한 점은, **숨겨진 출력을 반환값에 넘겨줘도 어딘가엔 적혀야 하기 때문이다.**

**시스템에서 숨겨진 출력을 완전히 없애지는 못한다.**

- 객체 상태 변경하는 것도 숨겨진 출력
- 인증 메일 보내는 행위도 숨겨진 출력
- 서버 간 네트워크 상태는 숨겨진 입력
- 자바 프록시도 숨겨진 입력

결국 시스템의 모든 외부 연동은 부수 효과를 동반한다는 점을 알고 있어야 한다. 그리고 입출력을 제거하기 위해 아등바등할 필요는 없지만, 입출력을 줄이고, **소프트웨어를 예측 가능하도록 만드는 목적이 집중하는 것이 훨씬 중요하다.**

### 함수형 프로그래밍

함수형 프로그래밍에서는 이러한 **숨겨진 입출력을 일컬어 '부수 효과(side-effect)'** 라고 한다. 그리고 함수에 부수효과가 있으면 이를 '비순수 함수'라고 하고, 부수 효과가 없으면 '순수 함수'라고 한다.

함수형 프로그래밍에서는 이 **부수 효과를 최대한 줄이는 방향**으로 프로그래밍 하는 것을 말한다.

하지만 함수형 프로그래밍에서도 '최대한 줄이는 방향'이지, **완전히 없앤다고는 말하지 않는다.** 

### 인터페이스

- 입력(매개변수)
- 출력(반환값)
- 시그니처(메서드 이름)

**이 3가지만 가지고 메서드의 동작과 호출 결과가 어떨지 추론해야 한다.**

### 정리

우리는 숨겨진 입출력을 드러냄으로써 좀 더 명확하게 테스트 할 수 있음과 동시에 유지보수, 확장성있는 설계를 유도한다는 것을 알게 되었다.

그리고 부수 효과를 완전히 없앨 순 없지만, 부수 효과를 줄이고 예측 가능성을 높여 결정적인 테스트를 만드는 것에 집중해야 한다.

# 테스트가 보내는 신호

책에 나오는 4가지 질문이 매우 중요하여 소개한다.

### Q. 테스트의 입출력을 확인할 수 없는데 이런 경우는 어떻게 해야 할까?

A. 숨겨진 입력은 외부로 드러내고, 숨겨진 출력은 반환값을 이용하자. 테스트 환경에서도 코드를 제어할 수 있게 변경하자.

### Q. private 메서드는 테스트 하기 힘든데, 어떻게 테스트 해야 하지?

A. 테스트 할 필요 없다. 책임을 잘못 할당했다는 신호일 수 있다.

### Q. 서비스 컴포넌트의 간단한 메서드를 테스트하고 싶을 뿐인데, 이를 위해 필요도 없는 객체를 너무 많이 주입한다..

A. **서비스 컴포넌트를 더 작은 단위로 나눠라**는 신호의 의미일 수 있다. UserService -> UserRegister -> 불필요한 의존성을 주입하기 위해 고정할 필요가 없다!

```java
new UserService(null, ...);
```

한 테스트에 필요없는 다른 의존성이 들어가 있는 것! 이것을 방지해야 한다.

### Q. 메서드의 코드 커버리지를 100% 달성하려면 테스트 할 케이스가 너무 많아진다.

A. 긴 코드로 인해 테스트 케이스가 너무 많아진다면 **해당 메서드의 책임이 너무 많이 할당된 것은 아닌지 고민해보자.**

또한 100%를 달성하는 것을 목표로 삼지 말자. 그보다 테스트가 책임을 제대로 수행하고 검증하고 있는지 돌이켜보자.

# 사용자

가장 중요한 부분이지 않을까 생각한다.

이 모든 것은, **테스트가 "코드 사용자 입장"에서 바라볼 수 있어서** 이런 고민들을 할 수 있었다.

- 설계, 책임 할당 등을 직접 볼 수 있다.
- 알고리즘이 아닌 요구사항 위주로 바라볼 수 있게 된다.

# 테스트와 SOLID

### SRP

테스트 코드를 작성해보니, 불필요한 의존성이 생겼다. 이는 테스트가 보내는 신호이다. 불필요한 의존성을 분리하라는 신호!

```
UserService -> UserRegister, AuthenticationService
```

⚠️ UserService를 생성할 때 다른 의존성은 `null`값을 부여할 수 있지만 이는 '신뢰할 수 없는 컴포넌트'이다. 이 부분은 따로 정리할 예정.

이를 SRP 관점에서도 보면, UserService는 

```
액터 - 시스템 미가입자
     - 시스템 가입자
```

서로 다른 메세지를 보내는 **두 명의 액터**가 있다고 볼 수 있기 때문에 SRP 위반이다.

또한, 테스트는 가능한 한 간결하고 **목적이 분리**되어 한 눈에 테스트하려고 하는 것이 무엇인지 눈에 들어와야 한다.

> 우리는 **테스트를 통해 의존성을 고민한 결과, 단일 책임 원칙을 지킬 수 있었다.**

### ISP

테스트를 통해 인터페이스를 분리하도록 유도할 수 있다.

```java
public interface EmailSender {
	void sendVerificationRequired(User user);
	void sendWelcome(User user);
	void sendAdvertisement(User user);
	void sendCharge(User user);
}
```

`EmailSender`는 User에 관한 이메일 전송 역할을 담당하고 있다.

여기서 회원 가입 테스트를 작성하고 싶은데, `sendVerificationRequired()`만 필요하고 나머지는 필요 없는 상황이다.

- Dummy 생성
- Fake 구현

근데, 애초에 회원 가입 테스트에 필요없는 나머지 3개를 신경써야 되는 상황 자체를 의심해야 한다.

**우리는 테스트를 만들 때 '우리가 테스트 하고 싶은 것'에만 관심을 두고 싶다. 그 외의 불필요한 의존과 인터페이스에 관심을 두고 싶지 않다.**

이는 인터페이스를 분리하라는 테스트의 신호이다!

```
EmailSender -> VerificationEmailSender
			-> WelcomeEmailSender
			-> AdvertisementEmailSender
			-> ChargeEmailSender
```

⚠️ **메서드 하나 당 인터페이스를 새로 만들라는 의미는 아니다! 인터페이스는 적당히 통합되고 세분화 되야 한다.** 이는 정말 어려운 일..

```java
public class FakeEmailSender implements 
			VerificationEmailSender, 
			AdvertisementEmailSender {

	public Map<String, String> emails = new HashMap<String, String>();

	@Override
	public void sendVerificationRequired(User user) {
		String content = VerificationEmailContentGenerator.generate(user);

		emails.put(user.getEmail(), content);
	}

	@Override
	public void sendAdvertisement(User user) {
		// do something..
	}
}
```

시간이 지나면서, 광고 메일을 추가해야 할 때, 이렇게 Fake 대역에 추가만 하면 된다. (혹은 Fake 대역을 분리해도 된다.)

이 구조의 중요한 점은 **필요할 때 확장이 가능하다**는 점이다. 이는 요구사항을 추가할 때 훨씬 유연하게 대처할 수 있다.

> **테스트를 통해 인터페이스(역할)를 분리하니, 인터페이스 분리 원칙을 지킬 수 있었다.**

🤔 Register, Reader, Updater, Deleter를 Service 단에서 분리하는 것에 대한 생각! 토론 각. 책의 430p를 살펴보자.

### OCP, DIP


- **테스트 대역**을 사용함으로써 **우리가 관심이 없는 부분을 대체**하도록 하여 관심사를 집중한다.
- 테스트의 **숨겨진 입력을 외부에 드러나게 함**으로써 테스트 할 때 상태 기반 검증 가능

**테스트 코드를 잘 작성하려 하는데 개방 폐쇄 원칙을 지킬 수 있었다.**

**배포 환경, 테스트 환경** 둘 다 원활하게 실행될 수 있게 만드는 것에서 이미 OCP를 유도한 것이라 볼 수 있다.

또한, **역할(interface)에 의존**하는 코드를 만들고 **역할에 충실한 컴포넌트**를 배포 환경이나 테스트 환경에 만들면 되는 점에서 **DIP 또한 지켜질 수 있다.**

### LSP

🤔 이부분을 잘 이해하지 못했다. LSP를 잘 이해하지 못한건지, 테스트와 LSP와의 관계를 이해하지 못한 건지 모르겠다.

테스트는 시스템의 상태를 검증하는 수단이다. 시스템이 유지했으면 하는 모든 상태를 테스트로 작성해야 한다. 

⚠️ 여기서 상태는 객체의 상태 그 이상으로 시스템 전체 관점에서 봐야 한다.

어떤 케이스에 대응하는 테스트가 시스템에 없다는 것은 '해당 케이스는 지속적으로 감시하면서까지 유지할 필요가 없다'라고 말하는 것과 같을 수 있다.

LSP 역시 시스템이 유지하고 싶은 상태 중 하나!

⚠️ 상속을 사용하는 것은 신중해야 한다. Square is kind of Rectangle이 우리 서비스에 맞는지 확인해야 한다. 그리고 상속 보다는 조합을 사용해야 한다. 인터페이스는 역할을 기반으로 만들어지는 것이 좋다.

### 정리

테스트 코드를 작성하면 SOLID 원칙까지 지킬 수 있게 유도되는 과정을 살펴보았다. 

테스트 환경과 배포 환경을 분리하려고 노력했더니 응집도는 높아지고 결합도는 낮아지는 설계로 나아갈 수 있었다.

테스트는 사용자 입장에서 바라보게 하는 아주 중요한 도구이다. 이를 잘 활용하도록 노력하자!

# 테스트와 개발 방법론

우리는 지금까지 테스트를 통해 회귀 버그를 탐지하고, 좋은 설계를 유도한다는 점을 배웠다.

이런 테스트의 강점을 활용할 수 있는 개발 방법론에 대해 알아보자.

### 켄트 벡의 두개의 모자

- 기능을 추가할 때
- 리팩토링 할 때

개발할 때 기능 구현 하다가 순간 리팩토링할 지점이 발견되서 리팩토링을 진행하다가 다시 기능 구현으로 돌아올 때 머릿 속에 정리가 안되고 개발이 산으로 가는 경우를 경험해 봤을 것이다.

이는 사용하는 뇌가 다르다는 의미이다. 그래서 켄트 벡은 "한 번에 하나의 모자만 써라"라고 조언한다.

### TDD

```
테스트를 먼저 작성한다 -> 기능을 구현한다 -> 리팩토링한다.
          red        ->     green      ->    refactor
```

우리가 익히 들었듯이 TDD는 위 3가지 단계가 전부이다.

객체지향, 절차적, 함수형 등 모든 패러다임에 적용시킬 수 있다.

하지만 초기 도메인 문제가 정확히 정해지지 않은 상황에서는 요구사항이나 인터페이스가 극단적으로 변경될 수도 있다. IT 업계의 일상이며, 이럴 경우엔 다음과 같은 문제점이 발생한다.

```
요구사항 분석 -> 테스트 코드 작성 -> 며칠 후 클라이언트가 요구사항을 변경했다는 소식 -> 방법이 없음. 처음부터 다시 요구사항 분석 및 테스트 작성...
```

이렇게 비효율적인 사이클이 반복된다.

> TDD는 은탄환이 아니다.

### BDD

TDD에서 파생된 소프트웨어 개발 방법론으로써, TDD의 한계를 해결하고자 등장하였다. 

TDD에 **'사용자 행동'** 이라는 가치를 덧붙인 개념이다. TDD를 하면서도 객체지향적인 설계를 얻기 위해 만든 이론으로 TDD에 DDD를 얹은 것.

BDD는 다음과 같은 flow를 가진다

```
사용자 행동을 '행동 명세'같은 요구사항으로 먼저 만든다. -> 이것이 테스트로 표현될 수 있게 만든다 -> 테스트는 요구사항 문서, 기획 문서의 역할을 가진다.
```

그리고 이러한 BDD를 실현하는 방법들 중 하나인 given-when-then을 주로 사용한다.

- given: 어떤 **상황**에서
- when: 어떤 **동작**이 주어질 때
- then: 요구되는 **상태**는 어떤 것인지

> 행동 명세
> 제목: 명시적인 제목
> 
> 서사
> - 주제는 누구인가
> - 주체가 원하는 것은 무엇인가
> - 주체의 행동 결과는 무엇인가
> 
> 시나리오 #1
> - Given: 주어진 상황
> - When: 시나리오가 발생하는 이벤트
> - Then: 시나리오 실행에 따른 기댓값
> 
> 시나리오 #2
> - Given: 주어진 상황
> - When: 시나리오가 발생하는 이벤트
> - Then: 시나리오 실행에 따른 기댓값

이렇게 기획 단계에서 '사용자 행동'을 설계한다면 이를 Test에 그대로 반영하는 방식이다. 

이렇게 해서 다음과 같은 이점을 얻을 수 있다.
- **개발자와 비개발자 사이의 협업**
- 행동 명세 작성
- **행동 명세의 테스트화**
- 테스트의 **문서화**

### 정리

이렇게 테스트의 강점을 활용하면서 DDD의 이론과 겹쳐진다면 훨씬 더 견고한 프로젝트 설계를 할 수 있을 것이라 생각한다.
