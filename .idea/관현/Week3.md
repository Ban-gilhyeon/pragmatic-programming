# 3주차

## H2 는 과연 deterministic 하게 동작하는가

인메모리 관계형 데이터베이스인 H2 는 별도의 데이터베이스 서버를 두지 않아도 테스트를 수행할 수 있다  
하지만 H2 를 연동한 테스트는 비결정적으로 동작할 가능성이 있다.  

이 테스트가 현재 개발 중인 코드베이스에만 영향을 받는 것이 아니라 H2 프로세스의 상태에도 영향을 받고, 프로세스 간  
통신 상태에도 영향을 받는다. 특히 병렬로 실행될 때 문제가 생길 수 있다. 여러 테스트가 동시에 단일 H2 서버에 접속해 테스트를  
진행할 경우 그 과정에서 데이터가 섞이고, 테스트가 예상하지 못한 방향으로 실행될 수 있다.  

+) H2 는 공유락을 명시적으로 설정하여도 select for update 구문이 나가게 된다  

## Fake 
테스트는 deterministic 한것도 중요하지만 속도도 역시 중요하다.  
Fake 를 사용한다면 로컬 환경에서 데이터베이스와 연동하지 않고도 서버를 구동시킬 수 있다.  

예를 들어, UserRepository 인터페이스를 implements 한 FakeUserRepository 에 간단한 메모리 변수를 갖고 있게 하는 것이다.  
-> save 를 하면 메모리 변수에 저장..  
-> PK 를 사용해야 하는데 AutoIncrement 가 설정되어있는 경우는..?  
-> Builder 로 pk 에 값을 넣어줄 수 있는 경우가 아니라면 곤란할 것 같다  


이렇게 Fake 객체를 만들면, 테스트 코드를 봤을 때 어떤 항목을 테스트하고 싶은지, 어떤 것들이 필요한지, 실행 결과의 기댓값이  
무엇인지 바로 파악 가능하다. (Stub 보다 이런 면에서 뛰어남)

스프링 프레임워크 구동, JPA 로딩을 기다릴 필요가 없다. Mockito 도 사용하지 않아도 된다  
-> 테스트 속도가 매우매우매우 빠르다  

이런 환경을 설정하기 위해서는 도메인이 비즈니스 로직을 처리해야 더 수월하게 작동할 수 있다.


## 상태 기반 검증과 행위 기반 검증

>상태 기반 검증: 테스트의 검증 동작에 상태를 사용, 테스트 실행한 후 테스트 대상의 상태가 어떻게 변화 되었는가  

> 행위 기반 검증: 테스트 검증 동작에 특정 메서드가 호출 되었는가..   
> `verify(user).removeBookmark("foobar");` -> `user.removeBookmark("foobar")` 가 호출 되었는가


가급적이면 테스트는 상태 기반 검증으로 작성하는 것이 좋다.. 행위 기반 검증은 사실상 알고리즘을 테스트하는 것  


## 숨겨진 입력과 숨겨진 출력

숨겨진 입력은 외부 사용자가 코드를 사용할 때 코드가 어떤 식으로 동작할 지 예상할 수 없게 만든다.  
명시된 입력에 같은 값을 넣어 같은 코드를 실행해도 다른 결과가 나오기 때문에 가급적 숨겨진 입력을 만들지 않아야 한다.  

-> 숨겨진 입력을 매개변수로 받는 방법..  


숨겨진 출력은 반환값 외에 존재하는 모든 부수적인 출력을 뜻함  
-> 전역 변수 변경역시 포함  
-> dto 로 해결 가능  



+) private 메서드는 테스트할 필요가 없음  

## 테스트와 SRP
서비스 컴포넌트를 더 작은 단위로 나누는 것을 고려하기  

우리가 흔히 사용하는 Service 클래스는 SRP 를 위반하고 있을 가능성이 매우 높음  
-> 더 작은 단위로 나눈다.  

물론 '무조건'은 절대 아님. 장단점 고려

## 테스트와 ISP

인터페이스를 세분화하더라도 구현 컴포넌트를 한개만 사용해도 됨  
실제 컴포넌트를 모두 따로 만들 필요는 없음 

나중에 필요할 때 추가로 구현하면 됨 -> 확장 가능, 유연성 증가  

기능적 응집도..!!